name: Repository

on:
  workflow_dispatch:
    branches-ignore: [dependabot/**]
    inputs:
      event:
        type: choice
        description: 'Type of event'     
        required: true
        options:
        - push
        - create
        - delete
      image-tag:
        description: 'Image tag for worker image'
        required: false
        default: 'latest'
  push:
    branches-ignore: [dependabot/**]
  # will also run if push and create happen together
  # create:
  #   branches-ignore: [dependabot/**]
  delete:
    branches-ignore: [dependabot/**]

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_PROFILE: ${{ vars.AWS_PROFILE }}
  AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
  AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  AWS_CLI_SERVICE: ecr
  ECR_REGISTRY_URI: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com
  IMAGE_TAG: ${{ github.sha }}
  ORG: ${{ github.repository_owner }}
  BRANCH: ${{ github.event_name == 'delete' && github.event.ref || (github.head_ref || github.ref_name) }}
  LOG_file: log.out

jobs:
  ecr-publish:
    name: ECR publish steps
    runs-on: ubuntu-latest
    environment: KookaS
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Set env
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "inputs.event=${{ inputs.event }}"
          REPO=$(basename ${{ github.repository }})
          echo "REPO: $REPO"
          IMAGE_KEEP_COUNT=$(if [[ $BRANCH == master ]]; then echo "5"; else echo "1"; fi)
          echo "IMAGE_KEEP_COUNT: $IMAGE_KEEP_COUNT"
          DOCKERFILES=$(
            jq --null-input \
              -c \
              --arg repo_bin "AWS_ECR_REPOSITORY=$(echo $ORG-$REPO-$BRANCH-bin | tr A-Z a-z)" \
              '[
                { "path":"Dockerfile.bin" },
                { "path":"Dockerfile","args": [ $repo_bin ] },
                { "path":"Dockerfile.bin","args": [ "VARIANT=mcr.microsoft.com/devcontainers/base:alpine-3.16" ], "extension": "devcontainer" }
              ]'
          )
          echo "DOCKERFILES: $DOCKERFILES"

          echo REPO=$REPO                           >> $GITHUB_ENV
          echo IMAGE_KEEP_COUNT=$IMAGE_KEEP_COUNT   >> $GITHUB_ENV
          echo DOCKERFILES=$DOCKERFILES             >> $GITHUB_ENV
      - name: Setup AWS CLI
        run: |
          aws --version
          aws configure set aws_access_key_id $AWS_ACCESS_KEY
          aws configure set aws_secret_access_key $AWS_SECRET_KEY
          aws configure set region $AWS_REGION
      - name: Login to ECR
        run: |
          if [[ $AWS_CLI_SERVICE == ecr ]]; then
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY_URI
          elif [[ $AWS_CLI_SERVICE == ecr-public ]]; then
            aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS ---password-stdin public.ecr.aws
          fi
      - name: Run workflow for each Dockerfile
        run: |
          # functions
          func_ecr_create () {
            echo -e '\033[43mCreating repository in ECR\033[0m'
            aws $AWS_CLI_SERVICE create-repository \
              --repository-name $ECR_REPOSITORY_NAME \
              --image-tag-mutability MUTABLE \
              --image-scanning-configuration scanOnPush=true \
              --tags Key=Account,Value=$AWS_PROFILE Key=Region,Value=$AWS_REGION Key=Organization,Value=$ORG Key=Repository,Value=$REPO Key=Branch,Value=$BRANCH
            json_string=$(
              jq --null-input \
                --argjson count "${IMAGE_KEEP_COUNT}" \
                '{
                  rules: [ 
                    { 
                      rulePriority: 1, 
                      description: "Keep only \($count) images", 
                      selection: { tagStatus: "any", 
                      countType: "imageCountMoreThan", countNumber: $count }, 
                      action: { type: "expire" } 
                    } 
                  ] 
                }'
            )
            echo $json_string > ecr-lifecycle-policy.json
            aws $AWS_CLI_SERVICE put-lifecycle-policy --repository-name $ECR_REPOSITORY_NAME --lifecycle-policy-text "file://ecr-lifecycle-policy.json"
            json_string=$(
              jq --null-input \
                --arg accountId "${AWS_ACCOUNT_ID}" \
                '{
                  Version: "2012-10-17", 
                  Statement: [ 
                    { 
                      Effect: "Allow", 
                      Principal: { Service: "ec2.amazonaws.com" }, 
                      Action: [ "ecr:BatchCheckLayerAvailability", "ecr:BatchGetImage", "ecr:GetDownloadUrlForLayer" ], 
                      Condition: { "StringEquals": { "aws:SourceAccount": $accountId } }
                    } 
                  ] 
                }'
            )
            echo $json_string > ecr-repository-policy.json
            aws $AWS_CLI_SERVICE set-repository-policy --repository-name $ECR_REPOSITORY_NAME --policy-text "file://ecr-repository-policy.json"
          }
          func_ecr_push () {
            # check existance of repository
            REPOSITORY_NAME_EXISTING=$(aws $AWS_CLI_SERVICE describe-repositories --repository-names $ECR_REPOSITORY_NAME --query 'repositories[0].repositoryName' || true)
            echo REPOSITORY_NAME_EXISTING=$REPOSITORY_NAME_EXISTING
            if [ -z ${REPOSITORY_NAME_EXISTING} ]; then
              func_ecr_create
            else
              echo -e '\033[46mRepository already exists\033[0m'
            fi

            # Push new image
            echo -e '\033[43mPushing image to ECR\033[0m'
            docker build --progress=plain --no-cache -t $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME/$IMAGE_TAG -f $DOCKERFILE_PATH $DOCKERFILE_ARGS .
            DOCKER_SRC=$(docker images -q $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME/$IMAGE_TAG)
            echo -e '\033[44mIMAGE SIZE\033[0m' $(docker inspect -f "{{ .Size }}" ${DOCKER_SRC} | numfmt --to=si)
            docker tag ${DOCKER_SRC} $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME:$IMAGE_TAG
            docker push $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME:$IMAGE_TAG
            docker tag $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME:$IMAGE_TAG $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME:latest
            docker push $ECR_REGISTRY_URI/$ECR_REPOSITORY_NAME:latest

            # Describe new image
            echo -e '\033[44mECR IMAGE THIS\033[0m'::
            aws $AWS_CLI_SERVICE describe-images --repository-name $ECR_REPOSITORY_NAME --image-ids imageTag=latest --output json
          }
          func_ecr () {
            # log save
            exec 3>&1 4>&2
            trap 'exec 2>&4 1>&3' 0 1 2 3
            exec 1>$LOG_FILE 2>&1

            # create/push/delete
            if [[ "${{ github.event_name }}" == "create" || ("${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.event }}" == "create") ]]; then
              func_ecr_create
            elif [[ "${{ github.event_name }}" == "push" || ("${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.event }}" == "push") ]]; then
              func_ecr_push
            elif [[ "${{ github.event_name }}" == "delete" || ("${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.event }}" == "delete") ]]; then
              echo -e '\033[43mDeleting repository in ECR\033[0m'
              aws ecr delete-repository --repository-name $ECR_REPOSITORY_NAME --force
            else
              echo -e '\033[41mError\033[0m'
              echo Error: event do not match, event_name ${{ github.event_name }}, inputs.event ${{ inputs.event }}
              exit 100
            fi
          }

          # loop over dockerfiles
          jq -rc '.[]' <<< "$DOCKERFILES" | while read dockerfile; do
            echo $dockerfile

            DOCKERFILE_PATH=$(jq -r '.path' <<< "$dockerfile")
            echo "DOCKERFILE_PATH:: $DOCKERFILE_PATH"

            # ecr extension name
            extension=$(jq -r '.extension' <<< "$dockerfile")
            if [[ -n "$extension" && $extension != null ]]; then
              dockerfile_extension="-$extension"
            else
              dockerfile_extension=$([[ "$DOCKERFILE_PATH" = *.* ]] && echo "-${DOCKERFILE_PATH##*.}" || echo '')
            fi
            echo dockerfile_extension:: $dockerfile_extension
            ECR_REPOSITORY_NAME="$(echo $ORG-$REPO-$BRANCH$dockerfile_extension | tr A-Z a-z)"
            echo ECR_REPOSITORY_NAME:: $ECR_REPOSITORY_NAME

            # docker build args
            DOCKERFILE_ARGS=""
            while read arg; do
              if [[ -n "$arg" ]]; then
                echo arg:: $arg
                DOCKERFILE_ARGS="$DOCKERFILE_ARGS --build-arg=$arg"
              fi
            done <<< "$(jq -rc '.args[]' <<< "$dockerfile")"
            echo DOCKERFILE_ARGS:: $DOCKERFILE_ARGS

            # run function
            $(func_ecr)

            # log print
            echo -e '\033[46mLOGS\033[0m'; cat $LOG_FILE
            if [ -n "$(grep -i error $LOG_FILE)" ]; then
              echo -e '\033[41mERRORS\033[0m'; grep -ni error $LOG_FILE | sed 's/$/\n/'; exit 10
            fi
          done